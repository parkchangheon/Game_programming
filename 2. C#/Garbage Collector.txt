c#에서의 GC

c#에서는 .NET 프레임워크가 제공하는 자동 메모리 관리를 이용한다.
c/cpp에서는 memory leak이 쉽게 발생.

.Net은 Managed heap이나 Stack에 메모리를 할당.

{
*관리되는 힙이란 Mono || IL2CPP의 메모리 관리자가 자동으로 관리하는 메모리 영역이다.
코드에서 생성된 모든 오브젝트는 관리되는 힙에 할당된다.

더 이상 참조되지 않는 오브젝트는 일정 시간마다 실행되는 GC에 의해 컬렉션이 된다.
컬럭션이 발생시, 참조되지 않은 오브젝트를 마킹하고 삭제하여 메모리를 확보한다.
(mark and sweap)

unity에서 사용하는 GC알고리즘은 Boehm 알고리즘으로 비세대, 비압축 방식으로 동작한다.

-비세대 기반이란 컬렉션 수행 시 특정 세대의 오브젝트만 순회하는 세대기반과 달리, 
힙에 할당된 모든 오브젝트를 순회하는 방식이다.
 * 힙에 할당된 오브젝트가 많을 수 록 컬렉션에 대한 부하가 커지고, 게임 성능 저하로 이어짐.

-비압축 기반이란 더 이상 참조되지 않는 오브젝트가 삭제된 이후, 오브젝트 사이에 있는 빈 공간을 제거하기 위해
오브젝트들을 재배치하지 않는 것을 의미 =====> 메모리 단편화 발생.

단편화 발생시, 전체적인 빈 공간이 충분함에도, 큰 오브젝트를 할당할 수 없는 문제가 생길 수 있다.
이런 상황 발생시 유니티 메모리 관리자는 GC를 실행해보고, 그럼에도 할당할 수 없다면, managed heap을 두배로 늘려버린다.

한번 확장된 힙은 빈 공간이 충분함에도 불구하고 다시 축소되지 않는다.

또한, managed heap이 확장/축소하면서 사용한 주소공간은 절대로 반환되지 않는다.

32비트의 주소공간은 4GB밖에 되지 않아, 확장 축소가 빈번히 일어나면, 결국 주소 공간이 부족해지고 
앱이 꺼지는 문제가 발생할 수 있다.
}


가비지 컬렉션은 언제 하느냐???

1. 객체를 할당하여 할당하는 임계치가 넘어갔을 때 (각 세대별)
2. GC.Collect 메서드를 호출할때
3. 시스템의 메모리가 부족할때


GC Root라는 것이 있다.
루트는 힙에 있는 객체를 가리키는 참조를 말한다.

if(true)
{
 object a = new object;
}

//a가 루트다.
루트는 스택 혹은 힙에 생성된다.


GC는 루트목록을 순회하면서, 루트가 참조하는 힙객체와 관게를 조사한다.
* 어떤 힙과도 루트와 관계가 없다면, 필요 없는 가비지.
* 다른 힙 객체를 참조 한다면 not garbage

그결과 객체가 있던 메모리는 비워준다.(sweap)
->이러한 방법 덕에 HEAP 전체를 검사할 필요는 없어, c/cpp보단 빠르다.
메모리 할당시 메모리 조각 현상이 발생하지 않는다.


그 이후, 저 부분을 비워주고 땡겨준다.(Compaction)
(루트 목록에 대한 조사 이후, GC가 힙을 순회하며 비어있는 공간에 인접 객체들을 이동시킴)

CLR은 메모리를 효율적으로 관리하기 위해, 세대를 나누는데 0,1,2 (0에 가까울 수록 메모리에서 빨리 사라짐 많이 안씀.)
0->1->2 순으로 세대가 바뀌거나 사라짐.
2세대 힙이 오브젝트로 가득차면 Full GC 상태.
CLR이 앱을 중단하고 모든 세대에 대해 GC 실행.

GC는 거의 반자동으로 이루어지지만

1. 우리는 객체를 많이 할당하려고 하면, FUll GC 상태에 도달한다.
=> 객체를 많이 할당x


2. 큰 객체를 할당한다면 대형 객체 힙은 2세대 힙으로 간주된다.
=> 대형 객체 힙은 메모리 공간 효율이 좋지 않아, 더욱 빠르게 GC를 요규하는 상황이 온다.

3. 참조되는 count가 많을 수록 GC에 객체가 살아남을 확률이 높다.






