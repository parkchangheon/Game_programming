오버로딩 : 함수 파라미터 타입이나 갯수만 다르게 해서 다른 함수로 인식하도록 하는 것
*함수의 리턴 타입만 다르게 해서는 오버로딩이 아니다.

void myprint(int i) { cout<< i <<endl; }
int myprint(int i) { cout <<i << endl; return i; }


오버라이딩 : 상속 관계에서 부모의 기능을 자식이 상속 받을 때, 자식이 부모의 기능을 재정의 하는 것.

virtual : 부모 클래스에서 정의된 걸 자식 클래스에서 재정의 할 것이라고 명시적으로 나타내는 키워드.

다형성 : 서로 다른 타입의 객체가 같은 이름의 동작을 서로 다르게 수행할 수 있는 것.

ex) 
class Monster{
 public : 
 list<Monster*> m_MonsterList;
 void attack() { cout << "monster attack()" << endl; } 
};

class Goblin : public Monster {
public :
 void attack() { cout<< "goblin attack" <<endl; }
};

class Dragon : public Monster {
public:
	void attack() { cout << "Dragon attack!" << endl; }
};

class Ghost : public Monster {
public:
	void attack() { cout << "Ghost attack!" << endl; }
};

Goblin* goblin = new Goblin;
Dragon* dragon = new Dragon;
Ghost* ghost = new Ghost;
Monster* monster = new Monster;

	monster->m_MonsterList.push_back(goblin);
	monster->m_MonsterList.push_back(dragon);
	monster->m_MonsterList.push_back(ghost);

	list<Monster*>::iterator iter = monster->m_MonsterList.begin();

	for (; iter != monster->m_MonsterList.end(); ++iter)
	{
		(*iter)->attack();
	}

	delete goblin;
	delete dragon;
	delete ghost;

이럴때, 고블린 드래곤 유령은 몬스터의 자식 클래스이고, 각 몬스터들을 한 리스트에 넣었다 꺼냈을때
각자 attack 멤버 함수를 호출할 것을 기대하고 있지만, 위 코드에서는 그렇지 않다.

구현하고자 하는 방식을 적용시키려면 각 attack 함수 앞에 virtual 키워드를 붙여주면서 구현이 가능



---------그렇다면 왜 이런 현상이 발생할까?

일반적으로 함수의 호출은 컴파일 타임에 호출할 함수의 주소를 결정하는 정적 바인딩을 사용한다.
1.의 경우에도 goblin*, drangon*, ghost*들이 monster* 타입의 리스트에 들어가면서 업캐스팅이 이루어졌을 것이다.
당연하게도 고블린, 드래곤, 유령은 몬스터로부터 상속받아 몬스터 타입이고, 컴파일러는 정적 바인딩을 하면
monster 클래스의 attack을 부를 수 밖에 없다.

이것을 동적 바인딩으로 처리하면 해결이 가능하다.
==> 객체의 포인터 타입을 보고 결정하는 것이 아니라 객체 포인터가 가리키는 것의 타입을 보고 
어떤 함수를 호출할지 결정한다. 이것이 런타임에 어떤 함수를 부를지 결정하게 되는 동적 바인딩이다.
함수가 virtual 키워드를 가지고 있으면 동적으로 바인딩이 된다.

각 객체를 위한 메모리 공간이 할당되면 그 공간엔 vtable pointer가 있는데, vitrual로 선언된 함수 호출시
vtable pointer가 가리키고 있는 테이블에 있는 함수의 주소를 보고 어떤 함수를 호출할지 결정한다.

	Parent * p = new Parent;
	Parent * c = new Child; 
	Child * cc = new Child;
	p->func1(); // Parent의 func1 함수 호출 
	c->func1(); // Child의 Overriding 된 func1 호출
	c->func2(); // Parent의 func2 함수 호출
	c->func4(); // Parent의 func4 함수 호출, 가상테이블엔 없음
	cc->func3(); // Child의 func3 함수 호출 


                                     Object         Parent::vftable
Parent *p = new Parent;  Parent::vatable   0x1001 0x2032 0x3156
------------------------------------------------------------------------------------
Parent *c = new Child;    Child::vtable      
							child::vftable ( 같이 씀)
                                                     0x1051 0x2032 0x2002  ..
Child *cc = new Child;    Child::vtable


** 주의 사항은 만약에 자식 클래스의 멤버중에 동적 할당된 것이 있어서 소멸자에게 그 동적 할당된 메모리를 해제해주고 있다면 반드시
부모의 소멸자를 virtual로 선언해줘야한다. 그래야 자식 클래스의 소멸자가 호출된다.

순수 가상 함수란, 부모 클래스에서 정의하지 않지만, 자식 클래스에서 재정의 해주어야 하는것. 
virtual 타입 함수명(파라미터) = 0 {}



















