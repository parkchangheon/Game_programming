#include<iostream>
using namespace std;




// **************************사이즈 (struct, union, class)*****************************************

union MyUnion
{
	int num;
	char* str;
	double numb;
}; //가장 큰 녀석의 사이즈를 받아 사용한다.

struct ssample
{
	char m1;
	short m2;
	int m3;
	long m4;
}; // 언뜻 보면 11 같지만, 12이다.  4 4 4 로 두고, int long은 해결, char short는 나머지로 쏘옥들어감.

class csample
{
	char m1;
	short m2;
	int m3;
	long m4;
}; //struct와 동문

// **************************************************************************






// ******************************   FSM   **************************************

//FSM( finite State Machine  ) 유한 상태 기계
/*
 유한 상태 기계는 자신이 취할 수 있는 유한한 갯수의 상태를 가짐.
 그중 하나의 상태만을 취함.
 현재 상태는 특정 조건이 되면 다른 상태로 변하기 가능
 유한 상태기계는 가능한 상태들의 집합과 각 상태들의 전이 조건으로 정의가능
 
 ex) 전구의 예
 전구는 on / off 두가지 상태를 갖는다. 
 전구는 둘중 하나의 상태만을 취한다.
 각 상태는 특정 조건 - 스위치 올려, 내려 에 따라 변함.
 전구를 다음과 같이 정의 가능
 1) on : 스위치가 올라가면 off로 전이
 2) off: 스위치가 내려가면 on으로 전이

 쓰는 이유는 
 가능한 상태들을 명확히 규정할 수 있다.
 상태 중복을 피할수 있다.
 전이를 명확히 규정가능하다.
 fsm에 기반한 객체를 만든다면 안정적인 작동을 보장할 수 있다.
*/



typedef enum { ON, OFF } BurbState;
typedef enum { ON, OFF } SwitchState;

class Burb
{
public:
	void Transition(SwitchState switchState)
	{
		switch (m_state)
		{
			case ON:
				if (switchState == OFF)
					m_state = BurbState::OFF;
				break;
				
			case OFF:
				if (switchState == ON)
					m_state = BurbState::ON;
				break;
		}
	}

private: 
	BurbState m_state;
};
/*
하지만 switch case로 작성하면, 조건이 복잡해진다면, 코드가 복잡해지고 유지보수가 힘들것이다.
계속해서 새로운 상태가 추가된다면, 상태가 추가될때마다 새로운 분기를 작성해주어야하고, 중복된 코드가 많아진다.
이런 문제를 해결하지 위해서 State 디자인 패턴을 적용


State 디자인 패턴

OOP의 다형성을 활용한다.
state를 추상클래스로 만들고 여러 상태들을 state를 상속받는 클래스로 구현



*/ 

// **************************************************************************





// ****************************세마포어와 뮤텍스***********************************
/*
프로세스 간 메시지를 전송하거나, 공유메모리를 통해 공유된 자원에 여러 개의 프로세스가 동시에 접근하면, critical section 문제가 발생할 수 있다.
이를 해결하기 위해 데이터를 한번에 하나의 프로세스만 접근할 수 있도록 제한을 두는 동기화 방식을 취하는데, 
대표적으로 뮤텍스와 세마포어가 있다.
이들은 모두 공유된 자원의 데이터를 여러 스레드/프로세스가 접근하는 것을 막는 역할을 한다.


<뮤텍스>
공유된 자원의 데이터 혹은 임계영역(critical section) 등에 하나의 프로세스 혹은 스레드가 접근하는 것을 막아줌. (동기화 대상이 하나이다)
임계구역을 가진 스레드들의 실행시간이 서로 겹치지 않고 각각 단독으로 실행.(상호배제) 되도록 함.
한 프로세스에 의해 소유될 수 있는 Key를 기반으로 한 상호배제 기법이고 Key에 해당하는 어떤 객체(Object)가 있으며, 이 객체를 소유한 스레드/프로세스만이 공유자원에 접근할 수 있습니다.
다중 프로세스들의 공유 리소스에 대한 접근을 조율하기 위해 동기화(Synchronization) 또는 락(Lock)을 사용함으로써 뮤텍스 객체를 두 스레드가 동시에 사용할 수 없다

ex) 화장실의 예
화장실이 하나밖에 없는 식당과 같은 원리.
화장실을 가기 위해, 카운터에서 열쇠를 받아가야 하며, 키가 있으면 비었다는 뜻이고, 없으면 비어있지 않다는 뜻이다.

즉 프로세스나 스레드는 어떠한 공유자원에 접근하기 필요한 키에 해당하는 오브젝트를 얻어야만 공유자원에 접근할 수 있다.


<세마포어>
공유된 자원의 데이터 혹은 임계 영역등에 여러 프로세스 혹은 스레드가 접근하는 것을 막아준다. (동기화 대상이 하나 이상)
사용하고 있는 스레드/프로세스의 수를 공통으로 관리하는 하나의 값을 이용해 상호배제를 달성합니다. 공유 자원에 접근할 수 있는 프로세스의 최대 허용치만큼 동시에 사용자가 접근할 수 있으며, 
각 프로세스는 세마포어의 값을 확인하고 변경할 수 있습니다.
자원을 사용하지 않는 상태가 될 때, 대기하던 프로세스가 즉시 자원을 사용하고. 이미 다른 프로세스에 의해 사용중이라는 사실을 알게 되면, 
재시도 전에 일정시간 대기해야 합니다.
일반적으로 비교적 긴 시간을 확보하는 리소스에 대해 사용하게 됩니다.

ex) 화장실의 예
화장실이 여러칸이 있다.
화장실 입구에는 빈칸 개수를 보여주는 판이 있다.
이용시, 빈칸 개수를 확인하고, 빈칸이 1개 이상이라면, 빈칸 개수를 빼고 이용.
나오면 더해줌.



차이점
가장 큰 차이점은 동기화 대상의 개수 즉, 위에서 예시든 화장실의 갯수 입니다.

Mutex는 동기화 대상이 오직 1개일 때 사용하며, Semaphore는 동기화 대상이 1개 이상일 때 사용합니다.
Mutex는 자원을 소유할 수 있고, 책임을 가지는 반면 Semaphore는 자원 소유가 불가합니다.
Mutex는 상태가 0, 1 뿐이므로 Lock을 가질 수 있고, 소유하고 있는 스레드만이 이 Mutex를 해제할 수 있습니다. 반면 Semaphore는 Semaphore를 소유하지 않는 스레드가 Semaphore를 해제할 수 있습니다.
Semaphore는 시스템 범위에 걸쳐 있고, 파일 시스템 상의 파일로 존재합니다. 반면, Mutex는 프로세스의 범위를 가지며 프로세스 종료될 때 자동으로 Clean up 됩니다.
*/
// **************************************************************************




int main()
{
	struct ssample s;
	union MyUnion u;
	csample c;
	cout << sizeof(s) << endl;
	cout << sizeof(u) << endl;
	cout << sizeof(c) << endl;

}



